import {traceJSON, _TRACE} from "./log"

const SEARCH_CUTOFF = Symbol.for("findsolution.cutoff");


// Performs tree search going through nodes in the order defined by queue.
// Nodes in the tree expanded using TreeExpander class instance
//   initialState - starting point for the search
//   treeGen class instance of TreeExpander
//	 checkTarget function accepts node.state, should return true if search target achieved
//	 use queue DFS for Depth First Search, BFS is used by default
function findOptimalSolution ({initialState, treeExpander, checkTarget, depthLimit = 0, queue = new BFS()}) {
	// Validate input params
	if(!(treeExpander instanceof TreeExpander)) throw new Error("treeGen parameter should be instanceof TreeExpander subclass");
	if(!queue.next || !queue.push) throw new Error("queue should have push and next functions defined");

	//Initialize either from the state or from queue
	var root;
	if(queue.length == 0) {
		root = new DecisionTreeNode({state: initialState});
		queue.push(root);
	} else {
		// If queue is not empty we expectits initialized with root node
		root = queue[0];
	}

	// Go through all nodes in the order defined by queue.next,
	// expanding every node further to the queue using treeGen.expandNode
	while(queue.length > 0) {
		let node = queue.next();
//		traceJSON("queue", queue);
		if(!(node instanceof DecisionTreeNode))
			throw new Error(`Incorrect node was generated by treeExpander: ${node}`);
		if(checkTarget(node.state))
			return new SuccessResult({node: node, root});
		if (depthLimit == 0 || node.depth < depthLimit) {
			traceJSON("Expanding node ", node)
			let expander = treeExpander.expandNode(node)
			if(queue.length > 10) expander = expander.filter(node => !node.duplicate(queue))
			queue.push(...expander)
//			traceJSON("Expanded node with ", expander)
		}
	}
	return new FailureResult(SEARCH_CUTOFF, {root});
}

// Action interface, action applied to node generates successor node
// Subclass must overload
//   .isApplicable(DecisionTreeNode)
//		returns true if action can be applied to the node.
//		Please note, cutting off nodes from the search can decrease search complexity
//		from O(b^d) to O(b*d) (e.g. increase performance), where b is average number
// 		of branches from usual node and d is search depth
//   .apply(DecisionTreeNode node)
//		should return successor state of a node.state, which will be automatically
//		wrapped into DecisionTreeNode
//   .cost()
//		cost of action later aggregated into path cost. By default cost of action is 1.
// Please note, subclass constructor can call super(props) to initialize its
// instance properties, in fact it just does following:
//		Object.assign(this, params); 
// Nevertheless action is a verb, its defined as class to let it contain its configuration
class SmartAction {
	constructor(params) {
		Object.assign(this, params); 
	}
	// apply action to decisionTreeNode.state, returns resulting state
	apply(decisionTreeNode) {
		throw new Error("SmartAction is abstract class, should not be instantiated");
	}
	isApplicable(decisionTreeNode) {
		throw new Error("SmartAction is abstract class, should not be instantiated");
	}
	cost() {
		return 1;
	}
}

// TreeExpander interface, action applied to node generates successor node
// Subclass must overload expandNode method, accepting treeNode instance of DecisionTreeNode, 
// returning array of expanded nodes instances of DecisionTreeNode
class TreeExpander {
	// treeNode
	expandNode(treeNode) {
		throw new Error("TreeExpander is abstract class, should not be instantiated");
	}
}

// Node leafs represent states, branch is action.
// Action is transforming node into successor node.
// New ActionsTreeExpander([new SmartAction1(), new SmartAction2()])
class ActionsTreeExpander extends TreeExpander {
	constructor(actions) {
		super();
		this.actions = actions;
	}
	expandNode(node) {
		return this.actions
			.filter(action => action.isApplicable(node))
			.map(action => {
				traceJSON("exec action", action);
				return node.addChild(action)});
	}
}


// DecisionTree is a resulting tree structure with state and action stored
class DecisionTreeNode {
	constructor({action = null, parent = null, state = null}) {
		this.parent = parent;
		this.state = (parent && action) ? action.apply(parent) : state;
		this.action = action;
		this.depth = parent ? (parent.depth + 1) : 0;
		this.children = [];
	}
	addChild(action) {
		var node = new DecisionTreeNode({action, parent: this})
		this.children.push(node);
		return node;
	}
	path() {
		if(this.depth == 0) return [ this ];
		let path = this.parent.path();
		path.push(this);
		return path;
	}
	duplicate(queue) {
		for(let node of queue)
			if(node.state.similar(this.state))
				return true;
		return false;
	}
}


// Search result types
class Result {
	constructor({success=true, result}) {
		this.success = success;
		this.result = result;
	}
}

// success result 
class SuccessResult extends Result {
	constructor({node, root}) {
		super({result: {node, root}});
	}
}

class FailureResult extends Result {
	constructor(failure, {root}) {
		super({success: false, result: {root}});
		this.failure = failure;
	}
}

// QUEUES: use for DFS or BFS search order
class DFS extends Array {
	next() {
		return this.pop()
	}
}

class BFS extends Array {
	next() {
		return this.shift()
	}
}

export { findOptimalSolution, Result, DecisionTreeNode, SmartAction, ActionsTreeExpander, DFS, BFS }
export default findOptimalSolution
